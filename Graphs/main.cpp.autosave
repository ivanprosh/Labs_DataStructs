#include  <stdio.h>
#include  <conio.h>
#include  <stdlib.h>
#include  <ctype.h>
#include  <string.h>
#include  <iostream>
#include  <Windows.h>

using namespace std;

class Node {
    int vertex;
    Node * next;
public:
    Node( ){ next = NULL; }
    ~Node( ){ if (next) delete next; }
    friend class GR;
};

const int MaxN = 700, MaxV = 26;
char Ch(int s) { return s+'a'; }

class GR {
    Node ** LIST;
    int num, * VISITED, * L, * STACK, ust, n, m;
public:
    void DBL (int v, int p);
    void Make (int [ MaxV ][ MaxV ]);
    void DBL_Exec( );
    GR(int);
    ~GR( );
};

GR::GR(int MaxV) : num(0), ust(0), n(0), m(0), LIST(new Node * [ MaxV ]), VISITED(new int[ MaxV ]), L(new int[ MaxV ]), STACK(new int[ MaxV ]) {}
GR :: ~GR() {delete []STACK; delete []L; delete []VISITED; delete []LIST; }

//void GR :: DBL_Exec()
//{
//    for (int i = 0; i < n; i++) { NUM[ i ] = 0; L[ i ] = 0; }
//    num = 0; ust = 0; 
//    for (int i = 0; i < n; i++) 
//        if (NUM[ i ] == 0) 
//            DBL( i, Ц1 );
    
//    cout << "\n" << "NUM="; for( int i = 0; i < n; i++) cout << NUM[i] << " ";
//    cout << "\n" << "  L="; for(int i=0; i<n; i++) cout << L[ I ] << " ";
//}
void GR :: DBL_Exec()
{
    for (int i = 0; i < n; i++) { VISITED[ i ] = 0; L[ i ] = 0; }
    num = 0; ust = 0; 
    for (int i = 0; i < n; i++) 
        if (VISITED[ i ] == 0) 
            DBL( i, Ц1 );
    
    cout << "\n" << "NUM="; for( int i = 0; i < n; i++) cout << VISITED[i] << " ";
    cout << "\n" << "  L="; for(int i=0; i<n; i++) cout << L[ I ] << " ";
}
//void GR :: DBL (int v, int p)
//{ Node * u;
//    int e1, e2;
//    NUM[ v ] = L[ v ] = ++num;
//    for (u = LIST[ v ]; u ; u = u->next)
//    { if (NUM[ u->d ] == 0)
//        { STACK[ ust++ ] = u->d; STACK[ ust++ ] = v;
//            cout << "\n" << "st1:"; for (int i=0; i<ust; i++) cout << Ch(STACK[ i ]); _getch();
//            DBL(u->d, v);
//            L[ v ] = L[ u->d ] < L[ v ] ? L[ u->d ] : L[ v ];
//            if (L[ u->d ] >= NUM[ v ])
//            {
//                cout << "\n" << "NUM="; for (int i = 0; i < n; i++) cout << NUM[ i ] << " ";
//                cout << "\n" << "  L="; for (int i = 0; i < n; i++) cout << L[ i ] << " ";
//                cout << "\n" << " ребро <" << Ch(v) << "-" << Ch(u->d) 
//                     << "> замыкает компоненту [";
//                do {
//                    e1 = STACK[ --ust ];
//                    e2 = STACK[ --ust ];
//                    cout << Ch(e1) << "-" << Ch(e2) << ';' ;
//                } while (((e1 != v) || (e2 != u->d)) && ( ust ));
//                cout << "] ";
//                cout << "\n" << "st3:"; for (int i = 0; i < ust; i++) cout << Ch(STACK[ i ]); _getch();
                
//            }
//        }
//        else if ((u->d != p) && (NUM[ u->d ] < NUM[ v ]))
//        { STACK[ ust++ ] = u->d; STACK[ ust++ ] = v;
//            cout << "\n" << "st2:"; for (int i = 0; i < ust; i++) cout << Ch(STACK[ i ]); _getch();
//            L[ v ] = NUM[ u->d ] < L[ v ] ? NUM[ u->d ] : L[ v ];
//        }
//    }
//    cout << " < " << v << '=' << NUM[ v ] << '/' << L[ v ];
//}
void GR :: DBL (int v, int p)
{ 
    Node * u;
    int e1, e2;
    VISITED[ v ] = L[ v ] = ++num;
    for (u = LIST[ v ]; u ; u = u->next)
    { 
        if (VISITED[ u->vertex ] == 0)
        { 
            STACK[ ust++ ] = u->vertex; 
            STACK[ ust++ ] = v;
            cout << "\n" << "st1:"; 
            for (int i=0; i<ust; i++) 
                cout << Ch(STACK[ i ]); 
            _getch();
            DBL(u->vertex, v);
            L[ v ] = L[ u->vertex ] < L[ v ] ? L[ u->vertex ] : L[ v ];
            if (L[ u->vertex ] >= VISITED[ v ])
            {
                cout << "\n" << "NUM="; for (int i = 0; i < n; i++) cout << VISITED[ i ] << " ";
                cout << "\n" << "  L="; for (int i = 0; i < n; i++) cout << L[ i ] << " ";
                cout << "\n" << " ребро <" << Ch(v) << "-" << Ch(u->vertex) 
                     << "> замыкает компоненту [";
                do {
                    e1 = STACK[ --ust ];
                    e2 = STACK[ --ust ];
                    cout << Ch(e1) << "-" << Ch(e2) << ';' ;
                } while (((e1 != v) || (e2 != u->vertex)) && ( ust ));
                cout << "] ";
                cout << "\n" << "st3:"; for (int i = 0; i < ust; i++) cout << Ch(STACK[ i ]); _getch();
                
            }
        }
        else if ((u->vertex != p) && (VISITED[ u->vertex ] < VISITED[ v ]))
        { 
            STACK[ ust++ ] = u->vertex; 
            STACK[ ust++ ] = v;
            cout << "\n" << "st2:"; 
            for (int i = 0; i < ust; i++) cout << Ch(STACK[ i ]); 
            _getch();
            L[ v ] = VISITED[ u->vertex ] < L[ v ] ? VISITED[ u->vertex ] : L[ v ];
        }
    }
    cout << " < " << v << '=' << VISITED[ v ] << '/' << L[ v ];
}

void GR :: Make(int G[ MaxV ][ MaxV ])
{
    int ls = 0, f;
    n = m = 0;
    for (int i=0; i<MaxV; i++)
    {
        LIST[ i ] = 0;
        G[ i ][ i ] = 0;
        f = 0;
        cout << "\n" << Ch(i) << ": ";
        for (int j = 0; j < MaxV; j++)
            if(G[ i ][ j ])
            {
                f++;
                Node *v = new Node;
                v->vertex = j;
                v->next = LIST[ i ];
                LIST[ i ] = v;
                cout << Ch( j );
            }
            else cout << "-";
        if( f ) n++;
        m += f;
        if (!(( ++ls ) % 10)) _getch();
    }
    cout << "\n" << "| V |=" << n <<  " | E |=" << m/2;
}
int main()
{
    int i, j, f, n = 0, G[ MaxV ][ MaxV ];
    char s[ 80 ];
    SetConsoleCP(1251);//дл€ корректного отображени€ русских букв в консоли, кодировка windows cp-1251
    SetConsoleOutputCP(1251); //

    for ( i = 0; i < MaxV; i++)
        for ( j = 0; j < MaxV; j++) G[ i ][ j ] = 0;
    cout << "\n" << "DBL test ============== (C)lgn, 10.10.03;14.01.13" <<
            "\n" << " ¬ведите списки смежности (строки букв a до z)..." << "\n";
    do{
        cout << "v[" << Ch(n) << "]=";
        cin >> s;
        cout << "\n" << "[" << s << "]" << strlen(s) << endl;
        _getch();
        for (int i = 0; i < strlen(s); i++)
            if (isalpha(s[ i ])){
                j = tolower(s[ i ]) - 'a';
                G[ n ][ j ] = 1;
            }
        n++;
    } while((strlen(s) > 0) && (n < MaxV) && s[0]!='0');
    //ѕреобразование строк в матрицу, затем Ц в списки смежности,
    //подсчЄт мощностей и контрольный вывод
    GR Gr(MaxN);
    Gr.Make(G);
    //“естирование функции DBL
    //Gr.DBL_Exec( );
    cout << "\n =====  онец =====\n";
    system("pause");
}


